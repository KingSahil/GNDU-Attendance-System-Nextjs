/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp";
exports.ids = ["vendor-chunks/tmp"];
exports.modules = {

/***/ "(ssr)/./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = { fs: fs.constants, os: os.constants };\n\n/*\n * The working inner variables.\n */\nconst // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n  EXIT = 'exit',\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\n\nlet _gracefulCleanup = false;\n\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */\nfunction rimraf(dirPath, callback) {\n  return fs.rm(dirPath, { recursive: true }, callback);\n}\n\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */\nfunction FN_RIMRAF_SYNC(dirPath) {\n  return fs.rmSync(dirPath, { recursive: true });\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {\n    if (err) return cb(err);\n\n    let tries = sanitizedOptions.tries;\n    (function _getUniqueName() {\n      try {\n        const name = _generateTmpName(sanitizedOptions);\n\n        // check whether the path exists then retry if needed\n        fs.stat(name, function (err) {\n          /* istanbul ignore else */\n          if (!err) {\n            /* istanbul ignore else */\n            if (tries-- > 0) return _getUniqueName();\n\n            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n          }\n\n          cb(null, name);\n        });\n      } catch (err) {\n        cb(err);\n      }\n    })();\n  });\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);\n\n  let tries = sanitizedOptions.tries;\n  do {\n    const name = _generateTmpName(sanitizedOptions);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (let i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePath(name, tmpDir, cb) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  fs.stat(pathToResolve, function (err) {\n    if (err) {\n      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {\n        if (err) return cb(err);\n\n        cb(null, path.join(parentDir, path.basename(pathToResolve)));\n      });\n    } else {\n      fs.realpath(pathToResolve, cb);\n    }\n  });\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePathSync(name, tmpDir) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  try {\n    fs.statSync(pathToResolve);\n    return fs.realpathSync(pathToResolve);\n  } catch (_err) {\n    const parentDir = fs.realpathSync(path.dirname(pathToResolve));\n\n    return path.join(parentDir, path.basename(pathToResolve));\n  }\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name)) {\n    return path.join(tmpDir, opts.dir, opts.name);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template)) {\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts and sanitizes the basic options.\n *\n * @private\n */\nfunction _assertOptionsBase(options) {\n  if (!_isUndefined(options.name)) {\n    const name = options.name;\n\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found \"${name}\".`);\n\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    const basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`name option must not contain a path, found \"${name}\".`);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {\n    throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n\n  /* istanbul ignore else */\n  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n  }\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Gets the relative directory to tmpDir.\n *\n * @private\n */\nfunction _getRelativePath(option, name, tmpDir, cb) {\n  if (_isUndefined(name)) return cb(null);\n\n  _resolvePath(name, tmpDir, function (err, resolvedPath) {\n    if (err) return cb(err);\n\n    const relativePath = path.relative(tmpDir, resolvedPath);\n\n    if (!resolvedPath.startsWith(tmpDir)) {\n      return cb(new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`));\n    }\n\n    cb(null, relativePath);\n  });\n}\n\n/**\n * Gets the relative path to tmpDir.\n *\n * @private\n */\nfunction _getRelativePathSync(option, name, tmpDir) {\n  if (_isUndefined(name)) return;\n\n  const resolvedPath = _resolvePathSync(name, tmpDir);\n  const relativePath = path.relative(tmpDir, resolvedPath);\n\n  if (!resolvedPath.startsWith(tmpDir)) {\n    throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`);\n  }\n\n  return relativePath;\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptions(options, cb) {\n  _getTmpDir(options, function (err, tmpDir) {\n    if (err) return cb(err);\n\n    options.tmpdir = tmpDir;\n\n    try {\n      _assertOptionsBase(options, tmpDir);\n    } catch (err) {\n      return cb(err);\n    }\n\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {\n      if (err) return cb(err);\n\n      options.dir = _isUndefined(dir) ? '' : dir;\n\n      // sanitize further if template is relative to options.dir\n      _getRelativePath('template', options.template, tmpDir, function (err, template) {\n        if (err) return cb(err);\n\n        options.template = template;\n\n        cb(null, options);\n      });\n    });\n  });\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptionsSync(options) {\n  const tmpDir = (options.tmpdir = _getTmpDirSync(options));\n\n  _assertOptionsBase(options, tmpDir);\n\n  const dir = _getRelativePathSync('dir', options.dir, tmpDir);\n  options.dir = _isUndefined(dir) ? '' : dir;\n\n  options.template = _getRelativePathSync('template', options.template, tmpDir);\n\n  return options;\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDir(options, cb) {\n  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDirSync(options) {\n  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDirSync();\n  }\n}));\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCLG1CQUFtQjtBQUNuQix1QkFBdUI7O0FBRXZCLHNCQUFzQjtBQUN0QiwwQkFBMEI7O0FBRTFCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2duZHUtYXR0ZW5kYW5jZS1uZXh0anMvLi9ub2RlX21vZHVsZXMvdG1wL2xpYi90bXAuanM/ZDUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRtcFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE3IEtBUkFTWkkgSXN0dmFuIDxnaXRodWJAc3BhbS5yYXN6aS5odT5cbiAqXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgX2MgPSB7IGZzOiBmcy5jb25zdGFudHMsIG9zOiBvcy5jb25zdGFudHMgfTtcblxuLypcbiAqIFRoZSB3b3JraW5nIGlubmVyIHZhcmlhYmxlcy5cbiAqL1xuY29uc3QgLy8gdGhlIHJhbmRvbSBjaGFyYWN0ZXJzIHRvIGNob29zZSBmcm9tXG4gIFJBTkRPTV9DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG4gIFRFTVBMQVRFX1BBVFRFUk4gPSAvWFhYWFhYLyxcbiAgREVGQVVMVF9UUklFUyA9IDMsXG4gIENSRUFURV9GTEFHUyA9IChfYy5PX0NSRUFUIHx8IF9jLmZzLk9fQ1JFQVQpIHwgKF9jLk9fRVhDTCB8fCBfYy5mcy5PX0VYQ0wpIHwgKF9jLk9fUkRXUiB8fCBfYy5mcy5PX1JEV1IpLFxuICAvLyBjb25zdGFudHMgYXJlIG9mZiBvbiB0aGUgd2luZG93cyBwbGF0Zm9ybSBhbmQgd2lsbCBub3QgbWF0Y2ggdGhlIGFjdHVhbCBlcnJubyBjb2Rlc1xuICBJU19XSU4zMiA9IG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicsXG4gIEVCQURGID0gX2MuRUJBREYgfHwgX2Mub3MuZXJybm8uRUJBREYsXG4gIEVOT0VOVCA9IF9jLkVOT0VOVCB8fCBfYy5vcy5lcnJuby5FTk9FTlQsXG4gIERJUl9NT0RFID0gMG83MDAgLyogNDQ4ICovLFxuICBGSUxFX01PREUgPSAwbzYwMCAvKiAzODQgKi8sXG4gIEVYSVQgPSAnZXhpdCcsXG4gIC8vIHRoaXMgd2lsbCBob2xkIHRoZSBvYmplY3RzIG5lZWQgdG8gYmUgcmVtb3ZlZCBvbiBleGl0XG4gIF9yZW1vdmVPYmplY3RzID0gW10sXG4gIC8vIEFQSSBjaGFuZ2UgaW4gZnMucm1kaXJTeW5jIGxlYWRzIHRvIGVycm9yIHdoZW4gcGFzc2luZyBpbiBhIHNlY29uZCBwYXJhbWV0ZXIsIGUuZy4gdGhlIGNhbGxiYWNrXG4gIEZOX1JNRElSX1NZTkMgPSBmcy5ybWRpclN5bmMuYmluZChmcyk7XG5cbmxldCBfZ3JhY2VmdWxDbGVhbnVwID0gZmFsc2U7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVtb3ZlIGEgZGlyZWN0b3J5IGFuZCBpdHMgY29udGVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpclBhdGggcGF0aCBvZiBkaXJlY3RvcnkgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmltcmFmKGRpclBhdGgsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBmcy5ybShkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVtb3ZlIGEgZGlyZWN0b3J5IGFuZCBpdHMgY29udGVudHMsIHN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpclBhdGggcGF0aCBvZiBkaXJlY3RvcnkgdG8gcmVtb3ZlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBGTl9SSU1SQUZfU1lOQyhkaXJQYXRoKSB7XG4gIHJldHVybiBmcy5ybVN5bmMoZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG59XG5cbi8qKlxuICogR2V0cyBhIHRlbXBvcmFyeSBmaWxlIG5hbWUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3x0bXBOYW1lQ2FsbGJhY2spfSBvcHRpb25zIG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSB7P3RtcE5hbWVDYWxsYmFja30gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0cywgZnVuY3Rpb24gKGVyciwgc2FuaXRpemVkT3B0aW9ucykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgbGV0IHRyaWVzID0gc2FuaXRpemVkT3B0aW9ucy50cmllcztcbiAgICAoZnVuY3Rpb24gX2dldFVuaXF1ZU5hbWUoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuYW1lID0gX2dlbmVyYXRlVG1wTmFtZShzYW5pdGl6ZWRPcHRpb25zKTtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwYXRoIGV4aXN0cyB0aGVuIHJldHJ5IGlmIG5lZWRlZFxuICAgICAgICBmcy5zdGF0KG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRyaWVzLS0gPiAwKSByZXR1cm4gX2dldFVuaXF1ZU5hbWUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiB0bXBOYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBuYW1lXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQgb3IgY291bGQgbm90IGdlbmVyYXRlIGEgZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gdG1wTmFtZVN5bmMob3B0aW9ucykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IHNhbml0aXplZE9wdGlvbnMgPSBfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zU3luYyhvcHRzKTtcblxuICBsZXQgdHJpZXMgPSBzYW5pdGl6ZWRPcHRpb25zLnRyaWVzO1xuICBkbyB7XG4gICAgY29uc3QgbmFtZSA9IF9nZW5lcmF0ZVRtcE5hbWUoc2FuaXRpemVkT3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfSB3aGlsZSAodHJpZXMtLSA+IDApO1xuXG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgb3BlbnMgYSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfG51bGx8dW5kZWZpbmVkfGZpbGVDYWxsYmFjayl9IG9wdGlvbnMgdGhlIGNvbmZpZyBvcHRpb25zIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuICogQHBhcmFtIHs/ZmlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaWxlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAvLyBjcmVhdGUgYW5kIG9wZW4gdGhlIGZpbGVcbiAgICBmcy5vcGVuKG5hbWUsIENSRUFURV9GTEFHUywgb3B0cy5tb2RlIHx8IEZJTEVfTU9ERSwgZnVuY3Rpb24gX2ZpbGVDcmVhdGVkKGVyciwgZmQpIHtcbiAgICAgIC8qIGlzdGFuYnUgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgICAgICByZXR1cm4gZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIF9kaXNjYXJkQ2FsbGJhY2socG9zc2libGVFcnIpIHtcbiAgICAgICAgICAvLyB0aGUgY2hhbmNlIG9mIGdldHRpbmcgYW4gZXJyb3Igb24gY2xvc2UgaGVyZSBpcyByYXRoZXIgbG93IGFuZCBtaWdodCBvY2N1ciBpbiB0aGUgbW9zdCBlZGdpZXN0IGNhc2VzIG9ubHlcbiAgICAgICAgICByZXR1cm4gY2IocG9zc2libGVFcnIsIG5hbWUsIHVuZGVmaW5lZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgLTEsIG9wdHMsIGZhbHNlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGV0YWNoRGVzY3JpcHRvciBwYXNzZXMgdGhlIGRlc2NyaXB0b3Igd2hlcmVhcyBkaXNjYXJkRGVzY3JpcHRvciBjbG9zZXMgaXQsIGVpdGhlciB3YXksIHdlIG5vIGxvbmdlciBjYXJlXG4gICAgICAgIC8vIGFib3V0IHRoZSBkZXNjcmlwdG9yXG4gICAgICAgIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgICAgICAgY2IobnVsbCwgbmFtZSwgZmQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPyAtMSA6IGZkLCBvcHRzLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGZpbGUuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RmlsZVN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lLCBmZCBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBjYW5ub3QgY3JlYXRlIGEgZmlsZVxuICovXG5mdW5jdGlvbiBmaWxlU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIGxldCBmZCA9IGZzLm9wZW5TeW5jKG5hbWUsIENSRUFURV9GTEFHUywgb3B0cy5tb2RlIHx8IEZJTEVfTU9ERSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICBmZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBmZDogZmQsXG4gICAgcmVtb3ZlQ2FsbGJhY2s6IF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPyAtMSA6IGZkLCBvcHRzLCB0cnVlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8ZGlyQ2FsbGJhY2spfSBvcHRpb25zIHRoZSBvcHRpb25zIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHs/ZGlyQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGRpcihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgLy8gZ2V0cyBhIHRlbXBvcmFyeSBmaWxlbmFtZVxuICB0bXBOYW1lKG9wdHMsIGZ1bmN0aW9uIF90bXBOYW1lQ3JlYXRlZChlcnIsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBjYihudWxsLCBuYW1lLCBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIGZhbHNlKSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZGlyLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0RpclN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGNhbm5vdCBjcmVhdGUgYSBkaXJlY3RvcnlcbiAqL1xuZnVuY3Rpb24gZGlyU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICBmcy5ta2RpclN5bmMobmFtZSwgb3B0cy5tb2RlIHx8IERJUl9NT0RFKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtb3ZlQ2FsbGJhY2s6IF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIGFzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmZFBhdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVGaWxlQXN5bmMoZmRQYXRoLCBuZXh0KSB7XG4gIGNvbnN0IF9oYW5kbGVyID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgIV9pc0VOT0VOVChlcnIpKSB7XG4gICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gIH07XG5cbiAgaWYgKDAgPD0gZmRQYXRoWzBdKVxuICAgIGZzLmNsb3NlKGZkUGF0aFswXSwgZnVuY3Rpb24gKCkge1xuICAgICAgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xuICAgIH0pO1xuICBlbHNlIGZzLnVubGluayhmZFBhdGhbMV0sIF9oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIHN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVTeW5jKGZkUGF0aCkge1xuICBsZXQgcmV0aHJvd25FeGNlcHRpb24gPSBudWxsO1xuICB0cnkge1xuICAgIGlmICgwIDw9IGZkUGF0aFswXSkgZnMuY2xvc2VTeW5jKGZkUGF0aFswXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgaWYgKCFfaXNFQkFERihlKSAmJiAhX2lzRU5PRU5UKGUpKSB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBmcy51bmxpbmtTeW5jKGZkUGF0aFsxXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcmVyYWlzZSBhbnkgdW5hbnRpY2lwYXRlZCBlcnJvclxuICAgICAgaWYgKCFfaXNFTk9FTlQoZSkpIHJldGhyb3duRXhjZXB0aW9uID0gZTtcbiAgICB9XG4gIH1cbiAgaWYgKHJldGhyb3duRXhjZXB0aW9uICE9PSBudWxsKSB7XG4gICAgdGhyb3cgcmV0aHJvd25FeGNlcHRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgY2FsbGJhY2sgZm9yIHJlbW92YWwgb2YgdGhlIHRlbXBvcmFyeSBmaWxlLlxuICpcbiAqIFJldHVybnMgZWl0aGVyIGEgc3luYyBjYWxsYmFjayBvciBhIGFzeW5jIGNhbGxiYWNrIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gKiBmaWxlU3luYyBvciBmaWxlIHdhcyBjYWxsZWQsIHdoaWNoIGlzIGV4cHJlc3NlZCBieSB0aGUgc3luYyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHBhdGggb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEByZXR1cm5zIHtmaWxlQ2FsbGJhY2sgfCBmaWxlQ2FsbGJhY2tTeW5jfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZmQsIG9wdHMsIHN5bmMpIHtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2tTeW5jID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhfcmVtb3ZlRmlsZVN5bmMsIFtmZCwgbmFtZV0sIHN5bmMpO1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soX3JlbW92ZUZpbGVBc3luYywgW2ZkLCBuYW1lXSwgc3luYywgcmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICBpZiAoIW9wdHMua2VlcCkgX3JlbW92ZU9iamVjdHMudW5zaGlmdChyZW1vdmVDYWxsYmFja1N5bmMpO1xuXG4gIHJldHVybiBzeW5jID8gcmVtb3ZlQ2FsbGJhY2tTeW5jIDogcmVtb3ZlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICpcbiAqIFJldHVybnMgZWl0aGVyIGEgc3luYyBjYWxsYmFjayBvciBhIGFzeW5jIGNhbGxiYWNrIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gKiB0bXBGaWxlU3luYyBvciB0bXBGaWxlIHdhcyBjYWxsZWQsIHdoaWNoIGlzIGV4cHJlc3NlZCBieSB0aGUgc3luYyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIHN5bmMpIHtcbiAgY29uc3QgcmVtb3ZlRnVuY3Rpb24gPSBvcHRzLnVuc2FmZUNsZWFudXAgPyByaW1yYWYgOiBmcy5ybWRpci5iaW5kKGZzKTtcbiAgY29uc3QgcmVtb3ZlRnVuY3Rpb25TeW5jID0gb3B0cy51bnNhZmVDbGVhbnVwID8gRk5fUklNUkFGX1NZTkMgOiBGTl9STURJUl9TWU5DO1xuICBjb25zdCByZW1vdmVDYWxsYmFja1N5bmMgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKHJlbW92ZUZ1bmN0aW9uU3luYywgbmFtZSwgc3luYyk7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgbmFtZSwgc3luYywgcmVtb3ZlQ2FsbGJhY2tTeW5jKTtcbiAgaWYgKCFvcHRzLmtlZXApIF9yZW1vdmVPYmplY3RzLnVuc2hpZnQocmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICByZXR1cm4gc3luYyA/IHJlbW92ZUNhbGxiYWNrU3luYyA6IHJlbW92ZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBndWFyZGVkIGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSByZW1vdmVGdW5jdGlvbiBjYWxsLlxuICpcbiAqIFRoZSBjbGVhbnVwIGNhbGxiYWNrIGlzIHNhdmUgdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICogU3Vic2VxdWVudCBpbnZvY2F0aW9ucyB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVtb3ZlRnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlT3JEaXJOYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luYz99IGNsZWFudXBDYWxsYmFja1N5bmNcbiAqIEByZXR1cm5zIHtjbGVhbnVwQ2FsbGJhY2sgfCBjbGVhbnVwQ2FsbGJhY2tTeW5jfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgZmlsZU9yRGlyTmFtZSwgc3luYywgY2xlYW51cENhbGxiYWNrU3luYykge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gaWYgc3luYyBpcyB0cnVlLCB0aGUgbmV4dCBwYXJhbWV0ZXIgd2lsbCBiZSBpZ25vcmVkXG4gIHJldHVybiBmdW5jdGlvbiBfY2xlYW51cENhbGxiYWNrKG5leHQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAvLyByZW1vdmUgY2xlYW51cENhbGxiYWNrIGZyb20gY2FjaGVcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gY2xlYW51cENhbGxiYWNrU3luYyB8fCBfY2xlYW51cENhbGxiYWNrO1xuICAgICAgY29uc3QgaW5kZXggPSBfcmVtb3ZlT2JqZWN0cy5pbmRleE9mKHRvUmVtb3ZlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaW5kZXggPj0gMCkgX3JlbW92ZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzeW5jIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9STURJUl9TWU5DIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9SSU1SQUZfU1lOQykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSwgbmV4dCB8fCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2FyYmFnZUNvbGxlY3RvcigpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfZ3JhY2VmdWxDbGVhbnVwKSByZXR1cm47XG5cbiAgLy8gdGhlIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCByZW1vdmVzIGl0c2VsZiBmcm9tIF9yZW1vdmVPYmplY3RzLFxuICAvLyBsb29wIHVudGlsIF9yZW1vdmVPYmplY3RzIGlzIGVtcHR5XG4gIHdoaWxlIChfcmVtb3ZlT2JqZWN0cy5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgX3JlbW92ZU9iamVjdHNbMF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlbW92ZWQ/XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmFuZG9tIG5hbWUgZ2VuZXJhdG9yIGJhc2VkIG9uIGNyeXB0by5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwOi8vYmxvZy50b21wYXdsYWsub3JnL2hvdy10by1nZW5lcmF0ZS1yYW5kb20tdmFsdWVzLW5vZGVqcy1qYXZhc2NyaXB0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGhvd01hbnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgcmFuZG9tIG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yYW5kb21DaGFycyhob3dNYW55KSB7XG4gIGxldCB2YWx1ZSA9IFtdLFxuICAgIHJuZCA9IG51bGw7XG5cbiAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgZG8gbm90IGZhaWwgYmVjYXVzZSB3ZSByYW4gb3V0IG9mIGVudHJvcHlcbiAgdHJ5IHtcbiAgICBybmQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoaG93TWFueSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBybmQgPSBjcnlwdG8ucHNldWRvUmFuZG9tQnl0ZXMoaG93TWFueSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgIHZhbHVlLnB1c2goUkFORE9NX0NIQVJTW3JuZFtpXSAlIFJBTkRPTV9DSEFSUy5sZW5ndGhdKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYG9iamAgcGFyYW1ldGVyIGlzIGRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgdW5kZWZpbmVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhlbHBzIHRvIGhhdmUgb3B0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8bnVsbHx1bmRlZmluZWR8RnVuY3Rpb24pfSBvcHRpb25zXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtBcnJheX0gcGFyc2VkIGFyZ3VtZW50c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBbe30sIG9wdGlvbnNdO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHJldHVybiBbe30sIGNhbGxiYWNrXTtcbiAgfVxuXG4gIC8vIGNvcHkgb3B0aW9ucyBzbyB3ZSBkbyBub3QgbGVhayB0aGUgY2hhbmdlcyB3ZSBtYWtlIGludGVybmFsbHlcbiAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcHRpb25zKSkge1xuICAgIGFjdHVhbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHJldHVybiBbYWN0dWFsT3B0aW9ucywgY2FsbGJhY2tdO1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgaW4gcmVzcGVjdCB0byB0bXBEaXIuXG4gKlxuICogVGhlIHNwZWNpZmllZCBuYW1lIG1pZ2h0IGluY2x1ZGUgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBlLmcuIC4uL1xuICogc28gd2UgbmVlZCB0byByZXNvbHZlIGluIG9yZGVyIHRvIGJlIHN1cmUgdGhhdCBpcyBpcyBsb2NhdGVkIGluc2lkZSB0bXBEaXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVBhdGgobmFtZSwgdG1wRGlyLCBjYikge1xuICBjb25zdCBwYXRoVG9SZXNvbHZlID0gcGF0aC5pc0Fic29sdXRlKG5hbWUpID8gbmFtZSA6IHBhdGguam9pbih0bXBEaXIsIG5hbWUpO1xuXG4gIGZzLnN0YXQocGF0aFRvUmVzb2x2ZSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZzLnJlYWxwYXRoKHBhdGguZGlybmFtZShwYXRoVG9SZXNvbHZlKSwgZnVuY3Rpb24gKGVyciwgcGFyZW50RGlyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICAgIGNiKG51bGwsIHBhdGguam9pbihwYXJlbnREaXIsIHBhdGguYmFzZW5hbWUocGF0aFRvUmVzb2x2ZSkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcy5yZWFscGF0aChwYXRoVG9SZXNvbHZlLCBjYik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBzcGVjaWZpZWQgcGF0aCBuYW1lIGluIHJlc3BlY3QgdG8gdG1wRGlyLlxuICpcbiAqIFRoZSBzcGVjaWZpZWQgbmFtZSBtaWdodCBpbmNsdWRlIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cywgZS5nLiAuLi9cbiAqIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSBpbiBvcmRlciB0byBiZSBzdXJlIHRoYXQgaXMgaXMgbG9jYXRlZCBpbnNpZGUgdG1wRGlyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQYXRoU3luYyhuYW1lLCB0bXBEaXIpIHtcbiAgY29uc3QgcGF0aFRvUmVzb2x2ZSA9IHBhdGguaXNBYnNvbHV0ZShuYW1lKSA/IG5hbWUgOiBwYXRoLmpvaW4odG1wRGlyLCBuYW1lKTtcblxuICB0cnkge1xuICAgIGZzLnN0YXRTeW5jKHBhdGhUb1Jlc29sdmUpO1xuICAgIHJldHVybiBmcy5yZWFscGF0aFN5bmMocGF0aFRvUmVzb2x2ZSk7XG4gIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICBjb25zdCBwYXJlbnREaXIgPSBmcy5yZWFscGF0aFN5bmMocGF0aC5kaXJuYW1lKHBhdGhUb1Jlc29sdmUpKTtcblxuICAgIHJldHVybiBwYXRoLmpvaW4ocGFyZW50RGlyLCBwYXRoLmJhc2VuYW1lKHBhdGhUb1Jlc29sdmUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyB0ZW1wb3JhcnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5ldyByYW5kb20gbmFtZSBhY2NvcmRpbmcgdG8gb3B0c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlVG1wTmFtZShvcHRzKSB7XG4gIGNvbnN0IHRtcERpciA9IG9wdHMudG1wZGlyO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghX2lzVW5kZWZpbmVkKG9wdHMubmFtZSkpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMubmFtZSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLnRlbXBsYXRlKSkge1xuICAgIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgb3B0cy50ZW1wbGF0ZSkucmVwbGFjZShURU1QTEFURV9QQVRURVJOLCBfcmFuZG9tQ2hhcnMoNikpO1xuICB9XG5cbiAgLy8gcHJlZml4IGFuZCBwb3N0Zml4XG4gIGNvbnN0IG5hbWUgPSBbXG4gICAgb3B0cy5wcmVmaXggPyBvcHRzLnByZWZpeCA6ICd0bXAnLFxuICAgICctJyxcbiAgICBwcm9jZXNzLnBpZCxcbiAgICAnLScsXG4gICAgX3JhbmRvbUNoYXJzKDEyKSxcbiAgICBvcHRzLnBvc3RmaXggPyAnLScgKyBvcHRzLnBvc3RmaXggOiAnJ1xuICBdLmpvaW4oJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgbmFtZSk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyBhbmQgc2FuaXRpemVzIHRoZSBiYXNpYyBvcHRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRPcHRpb25zQmFzZShvcHRpb25zKSB7XG4gIGlmICghX2lzVW5kZWZpbmVkKG9wdGlvbnMubmFtZSkpIHtcbiAgICBjb25zdCBuYW1lID0gb3B0aW9ucy5uYW1lO1xuXG4gICAgLy8gYXNzZXJ0IHRoYXQgbmFtZSBpcyBub3QgYWJzb2x1dGUgYW5kIGRvZXMgbm90IGNvbnRhaW4gYSBwYXRoXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZShuYW1lKSkgdGhyb3cgbmV3IEVycm9yKGBuYW1lIG9wdGlvbiBtdXN0IG5vdCBjb250YWluIGFuIGFic29sdXRlIHBhdGgsIGZvdW5kIFwiJHtuYW1lfVwiLmApO1xuXG4gICAgLy8gbXVzdCBub3QgZmFpbCBvbiB2YWxpZCAuPG5hbWU+IG9yIC4uPG5hbWU+IG9yIHNpbWlsYXIgc3VjaCBjb25zdHJ1Y3RzXG4gICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG5hbWUpO1xuICAgIGlmIChiYXNlbmFtZSA9PT0gJy4uJyB8fCBiYXNlbmFtZSA9PT0gJy4nIHx8IGJhc2VuYW1lICE9PSBuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYW1lIG9wdGlvbiBtdXN0IG5vdCBjb250YWluIGEgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSAmJiAhb3B0aW9ucy50ZW1wbGF0ZS5tYXRjaChURU1QTEFURV9QQVRURVJOKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSwgZm91bmQgXCIke29wdGlvbnMudGVtcGxhdGV9XCIuYCk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKCFfaXNVbmRlZmluZWQob3B0aW9ucy50cmllcykgJiYgaXNOYU4ob3B0aW9ucy50cmllcykpIHx8IG9wdGlvbnMudHJpZXMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyaWVzLCBmb3VuZCBcIiR7b3B0aW9ucy50cmllc31cIi5gKTtcbiAgfVxuXG4gIC8vIGlmIGEgbmFtZSB3YXMgc3BlY2lmaWVkIHdlIHdpbGwgdHJ5IG9uY2VcbiAgb3B0aW9ucy50cmllcyA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gb3B0aW9ucy50cmllcyB8fCBERUZBVUxUX1RSSUVTIDogMTtcbiAgb3B0aW9ucy5rZWVwID0gISFvcHRpb25zLmtlZXA7XG4gIG9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kZXRhY2hEZXNjcmlwdG9yO1xuICBvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yID0gISFvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yO1xuICBvcHRpb25zLnVuc2FmZUNsZWFudXAgPSAhIW9wdGlvbnMudW5zYWZlQ2xlYW51cDtcblxuICAvLyBmb3IgY29tcGxldGVuZXNzJyBzYWtlIG9ubHksIGFsc28ga2VlcCAobXVsdGlwbGUpIGJsYW5rcyBpZiB0aGUgdXNlciwgcHVycG9ydGVkbHkgc2FuZSwgcmVxdWVzdHMgdXMgdG9cbiAgb3B0aW9ucy5wcmVmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wcmVmaXgpID8gJycgOiBvcHRpb25zLnByZWZpeDtcbiAgb3B0aW9ucy5wb3N0Zml4ID0gX2lzVW5kZWZpbmVkKG9wdGlvbnMucG9zdGZpeCkgPyAnJyA6IG9wdGlvbnMucG9zdGZpeDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSByZWxhdGl2ZSBkaXJlY3RvcnkgdG8gdG1wRGlyLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRSZWxhdGl2ZVBhdGgob3B0aW9uLCBuYW1lLCB0bXBEaXIsIGNiKSB7XG4gIGlmIChfaXNVbmRlZmluZWQobmFtZSkpIHJldHVybiBjYihudWxsKTtcblxuICBfcmVzb2x2ZVBhdGgobmFtZSwgdG1wRGlyLCBmdW5jdGlvbiAoZXJyLCByZXNvbHZlZFBhdGgpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodG1wRGlyLCByZXNvbHZlZFBhdGgpO1xuXG4gICAgaWYgKCFyZXNvbHZlZFBhdGguc3RhcnRzV2l0aCh0bXBEaXIpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke3JlbGF0aXZlUGF0aH1cIi5gKSk7XG4gICAgfVxuXG4gICAgY2IobnVsbCwgcmVsYXRpdmVQYXRoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcmVsYXRpdmUgcGF0aCB0byB0bXBEaXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFJlbGF0aXZlUGF0aFN5bmMob3B0aW9uLCBuYW1lLCB0bXBEaXIpIHtcbiAgaWYgKF9pc1VuZGVmaW5lZChuYW1lKSkgcmV0dXJuO1xuXG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IF9yZXNvbHZlUGF0aFN5bmMobmFtZSwgdG1wRGlyKTtcbiAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSh0bXBEaXIsIHJlc29sdmVkUGF0aCk7XG5cbiAgaWYgKCFyZXNvbHZlZFBhdGguc3RhcnRzV2l0aCh0bXBEaXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke3JlbGF0aXZlUGF0aH1cIi5gKTtcbiAgfVxuXG4gIHJldHVybiByZWxhdGl2ZVBhdGg7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBhcmUgdmFsaWQsIGFsc28gc2FuaXRpemVzIG9wdGlvbnMgYW5kIHByb3ZpZGVzIHNhbmUgZGVmYXVsdHMgZm9yIG1pc3NpbmdcbiAqIG9wdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRpb25zLCBjYikge1xuICBfZ2V0VG1wRGlyKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHRtcERpcikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgb3B0aW9ucy50bXBkaXIgPSB0bXBEaXI7XG5cbiAgICB0cnkge1xuICAgICAgX2Fzc2VydE9wdGlvbnNCYXNlKG9wdGlvbnMsIHRtcERpcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzYW5pdGl6ZSBkaXIsIGFsc28ga2VlcCAobXVsdGlwbGUpIGJsYW5rcyBpZiB0aGUgdXNlciwgcHVycG9ydGVkbHkgc2FuZSwgcmVxdWVzdHMgdXMgdG9cbiAgICBfZ2V0UmVsYXRpdmVQYXRoKCdkaXInLCBvcHRpb25zLmRpciwgdG1wRGlyLCBmdW5jdGlvbiAoZXJyLCBkaXIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBvcHRpb25zLmRpciA9IF9pc1VuZGVmaW5lZChkaXIpID8gJycgOiBkaXI7XG5cbiAgICAgIC8vIHNhbml0aXplIGZ1cnRoZXIgaWYgdGVtcGxhdGUgaXMgcmVsYXRpdmUgdG8gb3B0aW9ucy5kaXJcbiAgICAgIF9nZXRSZWxhdGl2ZVBhdGgoJ3RlbXBsYXRlJywgb3B0aW9ucy50ZW1wbGF0ZSwgdG1wRGlyLCBmdW5jdGlvbiAoZXJyLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgICBvcHRpb25zLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICAgICAgY2IobnVsbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBhcmUgdmFsaWQsIGFsc28gc2FuaXRpemVzIG9wdGlvbnMgYW5kIHByb3ZpZGVzIHNhbmUgZGVmYXVsdHMgZm9yIG1pc3NpbmdcbiAqIG9wdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2Fzc2VydEFuZFNhbml0aXplT3B0aW9uc1N5bmMob3B0aW9ucykge1xuICBjb25zdCB0bXBEaXIgPSAob3B0aW9ucy50bXBkaXIgPSBfZ2V0VG1wRGlyU3luYyhvcHRpb25zKSk7XG5cbiAgX2Fzc2VydE9wdGlvbnNCYXNlKG9wdGlvbnMsIHRtcERpcik7XG5cbiAgY29uc3QgZGlyID0gX2dldFJlbGF0aXZlUGF0aFN5bmMoJ2RpcicsIG9wdGlvbnMuZGlyLCB0bXBEaXIpO1xuICBvcHRpb25zLmRpciA9IF9pc1VuZGVmaW5lZChkaXIpID8gJycgOiBkaXI7XG5cbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9nZXRSZWxhdGl2ZVBhdGhTeW5jKCd0ZW1wbGF0ZScsIG9wdGlvbnMudGVtcGxhdGUsIHRtcERpcik7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRUJBREYgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFQkFERihlcnJvcikge1xuICByZXR1cm4gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVCQURGLCAnRUJBREYnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFTk9FTlQgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFTk9FTlQoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FTk9FTlQsICdFTk9FTlQnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGV4cGVjdGVkIGVycm9yIGNvZGUgbWF0Y2hlcyB0aGUgYWN0dWFsIGNvZGUgYW5kIGVycm5vLFxuICogd2hpY2ggd2lsbCBkaWZmZXIgYmV0d2VlbiB0aGUgc3VwcG9ydGVkIG5vZGUgdmVyc2lvbnMuXG4gKlxuICogLSBOb2RlID49IDcuMDpcbiAqICAgZXJyb3IuY29kZSB7c3RyaW5nfVxuICogICBlcnJvci5lcnJubyB7bnVtYmVyfSBhbnkgbnVtZXJpY2FsIHZhbHVlIHdpbGwgYmUgbmVnYXRlZFxuICpcbiAqIENBVkVBVFxuICpcbiAqIE9uIHdpbmRvd3MsIHRoZSBlcnJubyBmb3IgRUJBREYgaXMgLTQwODMgYnV0IG9zLmNvbnN0YW50cy5lcnJuby5FQkFERiBpcyBkaWZmZXJlbnQgYW5kIHdlIG11c3QgYXNzdW1lIHRoYXQgRU5PRU5UXG4gKiBpcyBubyBkaWZmZXJlbnQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge1N5c3RlbUVycm9yfSBlcnJvclxuICogQHBhcmFtIHtudW1iZXJ9IGVycm5vXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgZXJybm8sIGNvZGUpIHtcbiAgcmV0dXJuIElTX1dJTjMyID8gZXJyb3IuY29kZSA9PT0gY29kZSA6IGVycm9yLmNvZGUgPT09IGNvZGUgJiYgZXJyb3IuZXJybm8gPT09IGVycm5vO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGdyYWNlZnVsIGNsZWFudXAuXG4gKlxuICogSWYgZ3JhY2VmdWwgY2xlYW51cCBpcyBzZXQsIHRtcCB3aWxsIHJlbW92ZSBhbGwgY29udHJvbGxlZCB0ZW1wb3Jhcnkgb2JqZWN0cyBvbiBwcm9jZXNzIGV4aXQsIG90aGVyd2lzZSB0aGVcbiAqIHRlbXBvcmFyeSBvYmplY3RzIHdpbGwgcmVtYWluIGluIHBsYWNlLCB3YWl0aW5nIHRvIGJlIGNsZWFuZWQgdXAgb24gc3lzdGVtIHJlc3RhcnQgb3Igb3RoZXJ3aXNlIHNjaGVkdWxlZCB0ZW1wb3JhcnlcbiAqIG9iamVjdCByZW1vdmFscy5cbiAqL1xuZnVuY3Rpb24gc2V0R3JhY2VmdWxDbGVhbnVwKCkge1xuICBfZ3JhY2VmdWxDbGVhbnVwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyIGZyb20gb3MudG1wZGlyKCkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFRtcERpcihvcHRpb25zLCBjYikge1xuICByZXR1cm4gZnMucmVhbHBhdGgoKG9wdGlvbnMgJiYgb3B0aW9ucy50bXBkaXIpIHx8IG9zLnRtcGRpcigpLCBjYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpciBmcm9tIG9zLnRtcGRpcigpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRUbXBEaXJTeW5jKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZzLnJlYWxwYXRoU3luYygob3B0aW9ucyAmJiBvcHRpb25zLnRtcGRpcikgfHwgb3MudG1wZGlyKCkpO1xufVxuXG4vLyBJbnN0YWxsIHByb2Nlc3MgZXhpdCBsaXN0ZW5lclxucHJvY2Vzcy5hZGRMaXN0ZW5lcihFWElULCBfZ2FyYmFnZUNvbGxlY3Rvcik7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXAgdGhlIHRlbXBvcmFyeSBvYmplY3QgKGZpbGUgb3IgZGlyKSB3aWxsIG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0cmllcyB0aGUgbnVtYmVyIG9mIHRyaWVzIGJlZm9yZSBnaXZlIHVwIHRoZSBuYW1lIGdlbmVyYXRpb25cbiAqIEBwcm9wZXJ0eSAoP2ludCkgbW9kZSB0aGUgYWNjZXNzIG1vZGUsIGRlZmF1bHRzIGFyZSAwbzcwMCBmb3IgZGlyZWN0b3JpZXMgYW5kIDBvNjAwIGZvciBmaWxlc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSB0ZW1wbGF0ZSB0aGUgXCJta3N0ZW1wXCIgbGlrZSBmaWxlbmFtZSB0ZW1wbGF0ZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBuYW1lIGZpeGVkIG5hbWUgcmVsYXRpdmUgdG8gdG1wZGlyIG9yIHRoZSBzcGVjaWZpZWQgZGlyIG9wdGlvblxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBkaXIgdG1wIGRpcmVjdG9yeSByZWxhdGl2ZSB0byB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IGluIHVzZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcG9zdGZpeCBwb3N0Zml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdG1wZGlyIHRoZSByb290IHRtcCBkaXJlY3Rvcnkgd2hpY2ggb3ZlcnJpZGVzIHRoZSBvcyB0bXBkaXJcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVuc2FmZUNsZWFudXAgcmVjdXJzaXZlbHkgcmVtb3ZlcyB0aGUgY3JlYXRlZCB0ZW1wb3JhcnkgZGlyZWN0b3J5LCBldmVuIHdoZW4gaXQncyBub3QgZW1wdHlcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRldGFjaERlc2NyaXB0b3IgZGV0YWNoZXMgdGhlIGZpbGUgZGVzY3JpcHRvciwgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjbG9zaW5nIHRoZSBmaWxlLCB0bXAgd2lsbCBubyBsb25nZXIgdHJ5IGNsb3NpbmcgdGhlIGZpbGUgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvblxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGlzY2FyZERlc2NyaXB0b3IgZGlzY2FyZHMgdGhlIGZpbGUgZGVzY3JpcHRvciAoY2xvc2VzIGZpbGUsIGZkIGlzIC0xKSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhcyBiZWVuIGRpc2NhcmRlZFxuICogQHByb3BlcnR5IHtmaWxlQ2FsbGJhY2t9IHJlbW92ZUNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGZpbGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERpclN5bmNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBkaXJlY3RvcnlcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayB0bXBOYW1lQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYWQgYmVlbiBkaXNjYXJkZWRcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1N5bmNcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtzaW1wbGVDYWxsYmFja30gW25leHRdIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbmV2ZXIgdGhlIHRtcCBvYmplY3QgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1N5bmNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXN6aS9ub2RlLXRtcC9pc3N1ZXMvNTd8cmFzemkvbm9kZS10bXAjNTd9XG4gKlxuICogQGNhbGxiYWNrIHNpbXBsZUNhbGxiYWNrXG4gKi9cblxuLy8gZXhwb3J0aW5nIGFsbCB0aGUgbmVlZGVkIG1ldGhvZHNcblxuLy8gZXZhbHVhdGUgX2dldFRtcERpcigpIGxhemlseSwgbWFpbmx5IGZvciBzaW1wbGlmeWluZyB0ZXN0aW5nIGJ1dCBpdCBhbHNvIHdpbGxcbi8vIGFsbG93IHVzZXJzIHRvIHJlY29uZmlndXJlIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICd0bXBkaXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0VG1wRGlyU3luYygpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuZGlyID0gZGlyO1xubW9kdWxlLmV4cG9ydHMuZGlyU3luYyA9IGRpclN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLmZpbGUgPSBmaWxlO1xubW9kdWxlLmV4cG9ydHMuZmlsZVN5bmMgPSBmaWxlU3luYztcblxubW9kdWxlLmV4cG9ydHMudG1wTmFtZSA9IHRtcE5hbWU7XG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lU3luYyA9IHRtcE5hbWVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRHcmFjZWZ1bENsZWFudXAgPSBzZXRHcmFjZWZ1bENsZWFudXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;